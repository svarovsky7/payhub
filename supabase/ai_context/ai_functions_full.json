{
  "public.add_working_days(start_date date, days_to_add integer)": {
    "schema": "public",
    "name": "add_working_days",
    "arguments": "start_date date, days_to_add integer",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.add_working_days(start_date date, days_to_add integer)\n RETURNS date\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n  result_date DATE := start_date;\n  working_days_added INTEGER := 0;\nBEGIN\n  WHILE working_days_added < days_to_add LOOP\n    result_date := result_date + INTERVAL '1 day';\n\n    -- Count only if not weekend\n    IF NOT is_weekend(result_date) THEN\n      working_days_added := working_days_added + 1;\n    END IF;\n  END LOOP;\n\n  RETURN result_date;\nEND;\n$function$\n",
    "comment": null
  },
  "public.calculate_material_class_level()": {
    "schema": "public",
    "name": "calculate_material_class_level",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.calculate_material_class_level()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.parent_id IS NULL THEN\n        NEW.level = 0;\n    ELSE\n        SELECT level + 1 INTO NEW.level\n        FROM material_classes\n        WHERE id = NEW.parent_id;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n",
    "comment": null
  },
  "public.calculate_preliminary_delivery_date(delivery_days integer, delivery_type character varying)": {
    "schema": "public",
    "name": "calculate_preliminary_delivery_date",
    "arguments": "delivery_days integer, delivery_type character varying",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.calculate_preliminary_delivery_date(delivery_days integer, delivery_type character varying)\n RETURNS date\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n  today DATE := CURRENT_DATE;\n  next_working_day DATE;\nBEGIN\n  -- If no delivery days specified, return NULL\n  IF delivery_days IS NULL OR delivery_days <= 0 THEN\n    RETURN NULL;\n  END IF;\n\n  -- Step 1: Find next working day from today\n  next_working_day := today + INTERVAL '1 day';\n  WHILE is_weekend(next_working_day) LOOP\n    next_working_day := next_working_day + INTERVAL '1 day';\n  END LOOP;\n\n  -- Step 2: Add delivery days based on type\n  IF delivery_type = 'working' THEN\n    RETURN add_working_days(next_working_day, delivery_days);\n  ELSE\n    -- Calendar days\n    RETURN next_working_day + (delivery_days || ' days')::INTERVAL;\n  END IF;\nEND;\n$function$\n",
    "comment": null
  },
  "public.delete_project(project_id_param integer)": {
    "schema": "public",
    "name": "delete_project",
    "arguments": "project_id_param integer",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.delete_project(project_id_param integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Удаляем все связи с пользователями\n  DELETE FROM public.user_projects WHERE project_id = project_id_param;\n\n  -- Удаляем сам проект\n  DELETE FROM public.projects WHERE id = project_id_param;\n\n  -- Возвращаем true если удаление прошло успешно\n  RETURN FOUND;\nEND;\n$function$\n",
    "comment": null
  },
  "public.get_material_class_path(class_id bigint)": {
    "schema": "public",
    "name": "get_material_class_path",
    "arguments": "class_id bigint",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.get_material_class_path(class_id bigint)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    path_text TEXT;\nBEGIN\n    WITH RECURSIVE class_path AS (\n        SELECT id, name, parent_id, name::TEXT as path\n        FROM material_classes\n        WHERE id = class_id\n\n        UNION ALL\n\n        SELECT c.id, c.name, c.parent_id,\n               p.name || ' → ' || cp.path\n        FROM material_classes c\n        INNER JOIN class_path cp ON c.id = cp.parent_id\n        INNER JOIN material_classes p ON p.id = c.id\n    )\n    SELECT path INTO path_text\n    FROM class_path\n    WHERE parent_id IS NULL;\n\n    RETURN COALESCE(path_text, (SELECT name FROM material_classes WHERE id = class_id));\nEND;\n$function$\n",
    "comment": null
  },
  "public.is_weekend(check_date date)": {
    "schema": "public",
    "name": "is_weekend",
    "arguments": "check_date date",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.is_weekend(check_date date)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nBEGIN\n  -- 0 = Sunday, 6 = Saturday\n  RETURN EXTRACT(DOW FROM check_date) IN (0, 6);\nEND;\n$function$\n",
    "comment": null
  },
  "public.log_approval_actions()": {
    "schema": "public",
    "name": "log_approval_actions",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.log_approval_actions()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    payment_entity_id uuid;\n    user_id_value uuid;\nBEGIN\n    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN\n        -- Получаем payment_id из payment_approvals\n        SELECT payment_id INTO payment_entity_id\n        FROM payment_approvals\n        WHERE id = NEW.payment_approval_id;\n\n        user_id_value := COALESCE(NEW.acted_by, (\n            SELECT created_by FROM payments WHERE id = payment_entity_id\n        ));\n\n        -- Логируем действие согласования\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES ('payment', payment_entity_id, 'approval_action', user_id_value,\n                jsonb_build_object(\n                    'approval_action', NEW.action,\n                    'stage_id', NEW.stage_id,\n                    'comment', NEW.comment,\n                    'acted_at', NEW.acted_at\n                ));\n\n        RETURN NEW;\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n",
    "comment": null
  },
  "public.log_attachment_changes()": {
    "schema": "public",
    "name": "log_attachment_changes",
    "arguments": "",
    "purpose": "Fixed function to handle null user_id by getting from invoice/payment",
    "sql": "CREATE OR REPLACE FUNCTION public.log_attachment_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    current_user_id uuid;\n    entity_type_name text;\n    entity_id_value uuid;\n    file_info jsonb;\nBEGIN\n    -- Определяем тип сущности и ID на основе таблицы и операции\n    IF TG_TABLE_NAME = 'invoice_attachments' THEN\n        entity_type_name := 'invoice';\n        IF TG_OP = 'DELETE' THEN\n            entity_id_value := OLD.invoice_id;\n        ELSE\n            entity_id_value := NEW.invoice_id;\n        END IF;\n    ELSIF TG_TABLE_NAME = 'payment_attachments' THEN\n        entity_type_name := 'payment';\n        IF TG_OP = 'DELETE' THEN\n            entity_id_value := OLD.payment_id;\n        ELSE\n            entity_id_value := NEW.payment_id;\n        END IF;\n    ELSE\n        RETURN COALESCE(NEW, OLD);\n    END IF;\n\n    -- Получаем текущего пользователя\n    current_user_id := current_setting('app.current_user_id', true)::uuid;\n\n    IF current_user_id IS NULL THEN\n        -- Пытаемся получить создателя файла из attachments\n        IF TG_OP = 'DELETE' THEN\n            SELECT created_by INTO current_user_id FROM attachments WHERE id = OLD.attachment_id;\n        ELSE\n            SELECT created_by INTO current_user_id FROM attachments WHERE id = NEW.attachment_id;\n        END IF;\n    END IF;\n\n    -- Если всё ещё null, берём создателя сущности (invoice или payment)\n    IF current_user_id IS NULL THEN\n        IF entity_type_name = 'invoice' THEN\n            SELECT user_id INTO current_user_id FROM invoices WHERE id = entity_id_value;\n        ELSIF entity_type_name = 'payment' THEN\n            SELECT user_id INTO current_user_id FROM payments WHERE id = entity_id_value;\n        END IF;\n    END IF;\n\n    -- Если всё ещё null, пропускаем аудит (не создаём запись с null user_id)\n    IF current_user_id IS NULL THEN\n        RETURN COALESCE(NEW, OLD);\n    END IF;\n\n    IF (TG_OP = 'INSERT') THEN\n        -- Получаем информацию о файле\n        SELECT jsonb_build_object(\n            'file_id', a.id,\n            'file_name', a.original_name,\n            'file_size', a.size_bytes,\n            'mime_type', a.mime_type\n        ) INTO file_info\n        FROM attachments a WHERE a.id = NEW.attachment_id;\n\n        -- Логируем добавление файла\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES (entity_type_name, entity_id_value, 'file_add', current_user_id, file_info);\n\n        RETURN NEW;\n\n    ELSIF (TG_OP = 'DELETE') THEN\n        -- Пытаемся получить информацию о файле (может уже быть удалён)\n        SELECT jsonb_build_object(\n            'file_id', a.id,\n            'file_name', a.original_name,\n            'file_size', a.size_bytes\n        ) INTO file_info\n        FROM attachments a WHERE a.id = OLD.attachment_id;\n\n        -- Если файл уже удалён, используем минимальную информацию\n        IF file_info IS NULL THEN\n            file_info := jsonb_build_object(\n                'file_id', OLD.attachment_id,\n                'file_name', 'Файл удалён'\n            );\n        END IF;\n\n        -- Логируем удаление файла\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES (entity_type_name, entity_id_value, 'file_delete', current_user_id, file_info);\n\n        RETURN OLD;\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n",
    "comment": "Fixed function to handle null user_id by getting from invoice/payment"
  },
  "public.log_invoice_changes()": {
    "schema": "public",
    "name": "log_invoice_changes",
    "arguments": "",
    "purpose": "Расширенная функция логирования изменений счетов с дополнительными полями",
    "sql": "CREATE OR REPLACE FUNCTION public.log_invoice_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    current_user_id uuid;\nBEGIN\n    -- Получаем текущего пользователя (можно передавать через session variable)\n    current_user_id := current_setting('app.current_user_id', true)::uuid;\n\n    IF current_user_id IS NULL THEN\n        -- Для DELETE используем OLD.user_id, для INSERT/UPDATE используем NEW.user_id\n        IF (TG_OP = 'DELETE') THEN\n            current_user_id := OLD.user_id;\n        ELSE\n            current_user_id := NEW.user_id;\n        END IF;\n    END IF;\n\n    IF (TG_OP = 'INSERT') THEN\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES ('invoice', NEW.id, 'create', current_user_id,\n                jsonb_build_object('invoice_number', NEW.invoice_number, 'amount', NEW.amount_with_vat));\n        RETURN NEW;\n\n    ELSIF (TG_OP = 'UPDATE') THEN\n        -- Логируем изменения полей\n\n        -- Номер счета\n        IF OLD.invoice_number IS DISTINCT FROM NEW.invoice_number THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'invoice_number', OLD.invoice_number, NEW.invoice_number, current_user_id);\n        END IF;\n\n        -- Дата счета\n        IF OLD.invoice_date IS DISTINCT FROM NEW.invoice_date THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'invoice_date', OLD.invoice_date::text, NEW.invoice_date::text, current_user_id);\n        END IF;\n\n        -- Сумма с НДС\n        IF OLD.amount_with_vat IS DISTINCT FROM NEW.amount_with_vat THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'amount_with_vat', OLD.amount_with_vat::text, NEW.amount_with_vat::text, current_user_id);\n        END IF;\n\n        -- Ставка НДС\n        IF OLD.vat_rate IS DISTINCT FROM NEW.vat_rate THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'vat_rate', OLD.vat_rate::text, NEW.vat_rate::text, current_user_id);\n        END IF;\n\n        -- Статус\n        IF OLD.status_id IS DISTINCT FROM NEW.status_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'status_change', 'status_id', OLD.status_id::text, NEW.status_id::text, current_user_id,\n                    jsonb_build_object('old_status_name', (SELECT name FROM invoice_statuses WHERE id = OLD.status_id),\n                                     'new_status_name', (SELECT name FROM invoice_statuses WHERE id = NEW.status_id)));\n        END IF;\n\n        -- Плательщик\n        IF OLD.payer_id IS DISTINCT FROM NEW.payer_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'payer_id', OLD.payer_id::text, NEW.payer_id::text, current_user_id,\n                    jsonb_build_object('old_payer_name', (SELECT name FROM contractors WHERE id = OLD.payer_id),\n                                     'new_payer_name', (SELECT name FROM contractors WHERE id = NEW.payer_id)));\n        END IF;\n\n        -- Поставщик\n        IF OLD.supplier_id IS DISTINCT FROM NEW.supplier_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'supplier_id', OLD.supplier_id::text, NEW.supplier_id::text, current_user_id,\n                    jsonb_build_object('old_supplier_name', (SELECT name FROM contractors WHERE id = OLD.supplier_id),\n                                     'new_supplier_name', (SELECT name FROM contractors WHERE id = NEW.supplier_id)));\n        END IF;\n\n        -- Проект\n        IF OLD.project_id IS DISTINCT FROM NEW.project_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'project_id', OLD.project_id::text, NEW.project_id::text, current_user_id,\n                    jsonb_build_object('old_project_name', (SELECT name FROM projects WHERE id = OLD.project_id),\n                                     'new_project_name', (SELECT name FROM projects WHERE id = NEW.project_id)));\n        END IF;\n\n        -- Договор\n        IF OLD.contract_id IS DISTINCT FROM NEW.contract_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'contract_id', OLD.contract_id::text, NEW.contract_id::text, current_user_id,\n                    jsonb_build_object('old_contract_number', (SELECT contract_number FROM contracts WHERE id = OLD.contract_id),\n                                     'new_contract_number', (SELECT contract_number FROM contracts WHERE id = NEW.contract_id)));\n        END IF;\n\n        -- Ответственный менеджер\n        IF OLD.responsible_id IS DISTINCT FROM NEW.responsible_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'responsible_id', OLD.responsible_id::text, NEW.responsible_id::text, current_user_id,\n                    jsonb_build_object('old_responsible_name', (SELECT full_name FROM user_profiles WHERE id = OLD.responsible_id),\n                                     'new_responsible_name', (SELECT full_name FROM user_profiles WHERE id = NEW.responsible_id)));\n        END IF;\n\n        -- Заявка на материалы\n        IF OLD.material_request_id IS DISTINCT FROM NEW.material_request_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'material_request_id', OLD.material_request_id::text, NEW.material_request_id::text, current_user_id,\n                    jsonb_build_object('old_request_number', (SELECT request_number FROM material_requests WHERE id = OLD.material_request_id),\n                                     'new_request_number', (SELECT request_number FROM material_requests WHERE id = NEW.material_request_id)));\n        END IF;\n\n        -- Стоимость доставки\n        IF OLD.delivery_cost IS DISTINCT FROM NEW.delivery_cost THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'delivery_cost', OLD.delivery_cost::text, NEW.delivery_cost::text, current_user_id);\n        END IF;\n\n        -- Срок поставки (дни)\n        IF OLD.delivery_days IS DISTINCT FROM NEW.delivery_days THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('invoice', NEW.id, 'update', 'delivery_days', OLD.delivery_days::text, NEW.delivery_days::text, current_user_id,\n                    jsonb_build_object('old_delivery_days_type', OLD.delivery_days_type,\n                                     'new_delivery_days_type', NEW.delivery_days_type));\n        END IF;\n\n        -- Тип дней поставки (рабочие/календарные)\n        IF OLD.delivery_days_type IS DISTINCT FROM NEW.delivery_days_type THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'delivery_days_type', OLD.delivery_days_type, NEW.delivery_days_type, current_user_id);\n        END IF;\n\n        -- Предварительная дата поставки\n        IF OLD.preliminary_delivery_date IS DISTINCT FROM NEW.preliminary_delivery_date THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'preliminary_delivery_date', OLD.preliminary_delivery_date::text, NEW.preliminary_delivery_date::text, current_user_id);\n        END IF;\n\n        -- Срок оплаты\n        IF OLD.due_date IS DISTINCT FROM NEW.due_date THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'due_date', OLD.due_date::text, NEW.due_date::text, current_user_id);\n        END IF;\n\n        -- Описание\n        IF OLD.description IS DISTINCT FROM NEW.description THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'description', OLD.description, NEW.description, current_user_id);\n        END IF;\n\n        -- Архивирование\n        IF OLD.is_archived IS DISTINCT FROM NEW.is_archived THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('invoice', NEW.id, 'update', 'is_archived', OLD.is_archived::text, NEW.is_archived::text, current_user_id);\n        END IF;\n\n        RETURN NEW;\n\n    ELSIF (TG_OP = 'DELETE') THEN\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES ('invoice', OLD.id, 'delete', current_user_id,\n                jsonb_build_object('invoice_number', OLD.invoice_number));\n        RETURN OLD;\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n",
    "comment": "Расширенная функция логирования изменений счетов с дополнительными полями"
  },
  "public.log_payment_changes()": {
    "schema": "public",
    "name": "log_payment_changes",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.log_payment_changes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    current_user_id uuid;\nBEGIN\n    -- Получаем текущего пользователя\n    current_user_id := current_setting('app.current_user_id', true)::uuid;\n\n    IF current_user_id IS NULL THEN\n        -- Для DELETE используем OLD.created_by, для INSERT/UPDATE используем NEW.created_by\n        IF (TG_OP = 'DELETE') THEN\n            current_user_id := OLD.created_by;\n        ELSE\n            current_user_id := NEW.created_by;\n        END IF;\n    END IF;\n\n    IF (TG_OP = 'INSERT') THEN\n        -- Логируем создание платежа\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES ('payment', NEW.id, 'create', current_user_id,\n                jsonb_build_object('payment_number', NEW.payment_number, 'amount', NEW.amount, 'invoice_id', NEW.invoice_id));\n        RETURN NEW;\n\n    ELSIF (TG_OP = 'UPDATE') THEN\n        -- Логируем изменения полей\n\n        IF OLD.payment_number IS DISTINCT FROM NEW.payment_number THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('payment', NEW.id, 'update', 'payment_number', OLD.payment_number::text, NEW.payment_number::text, current_user_id);\n        END IF;\n\n        IF OLD.amount IS DISTINCT FROM NEW.amount THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('payment', NEW.id, 'update', 'amount', OLD.amount::text, NEW.amount::text, current_user_id);\n        END IF;\n\n        IF OLD.payment_date IS DISTINCT FROM NEW.payment_date THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('payment', NEW.id, 'update', 'payment_date', OLD.payment_date::text, NEW.payment_date::text, current_user_id);\n        END IF;\n\n        IF OLD.status_id IS DISTINCT FROM NEW.status_id THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id, metadata)\n            VALUES ('payment', NEW.id, 'status_change', 'status_id', OLD.status_id::text, NEW.status_id::text, current_user_id,\n                    jsonb_build_object('old_status_name', (SELECT name FROM payment_statuses WHERE id = OLD.status_id),\n                                     'new_status_name', (SELECT name FROM payment_statuses WHERE id = NEW.status_id)));\n        END IF;\n\n        IF OLD.is_archived IS DISTINCT FROM NEW.is_archived THEN\n            INSERT INTO public.audit_log (entity_type, entity_id, action, field_name, old_value, new_value, user_id)\n            VALUES ('payment', NEW.id, 'update', 'is_archived', OLD.is_archived::text, NEW.is_archived::text, current_user_id);\n        END IF;\n\n        RETURN NEW;\n\n    ELSIF (TG_OP = 'DELETE') THEN\n        -- Логируем удаление платежа\n        INSERT INTO public.audit_log (entity_type, entity_id, action, user_id, metadata)\n        VALUES ('payment', OLD.id, 'delete', current_user_id,\n                jsonb_build_object('payment_number', OLD.payment_number));\n        RETURN OLD;\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n",
    "comment": null
  },
  "public.recalculate_invoice_delivery_date()": {
    "schema": "public",
    "name": "recalculate_invoice_delivery_date",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.recalculate_invoice_delivery_date()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Recalculate delivery date for the affected invoice\n  UPDATE invoices\n  SET preliminary_delivery_date = calculate_preliminary_delivery_date(\n    delivery_days,\n    delivery_days_type\n  )\n  WHERE id = COALESCE(NEW.invoice_id, OLD.invoice_id)\n    AND delivery_days IS NOT NULL\n    AND delivery_days > 0\n    AND status_id != 3;  -- Don't update if invoice is already fully paid\n\n  RETURN NEW;\nEND;\n$function$\n",
    "comment": null
  },
  "public.update_material_request_items_count()": {
    "schema": "public",
    "name": "update_material_request_items_count",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.update_material_request_items_count()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        -- При добавлении элемента увеличиваем счетчик\n        UPDATE material_requests\n        SET total_items = COALESCE(total_items, 0) + 1\n        WHERE id = NEW.material_request_id;\n    ELSIF TG_OP = 'DELETE' THEN\n        -- При удалении элемента уменьшаем счетчик\n        UPDATE material_requests\n        SET total_items = GREATEST(COALESCE(total_items, 0) - 1, 0)\n        WHERE id = OLD.material_request_id;\n    END IF;\n    RETURN NULL;\nEND;\n$function$\n",
    "comment": null
  },
  "public.update_preliminary_delivery_dates()": {
    "schema": "public",
    "name": "update_preliminary_delivery_dates",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.update_preliminary_delivery_dates()\n RETURNS TABLE(invoice_id uuid, old_date date, new_date date)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  UPDATE invoices i\n  SET preliminary_delivery_date = calculate_preliminary_delivery_date(\n    i.delivery_days,\n    i.delivery_days_type\n  )\n  WHERE\n    -- Only update invoices with delivery days specified\n    i.delivery_days IS NOT NULL\n    AND i.delivery_days > 0\n    -- Only update if not fully paid (status_id != 3)\n    -- Status IDs: 1=draft, 2=pending, 3=paid, 4=partial, 5=cancelled\n    AND i.status_id != 3\n    -- Only update if there are no paid payments\n    AND NOT EXISTS (\n      SELECT 1\n      FROM invoice_payments ip\n      JOIN payments p ON ip.payment_id = p.id\n      WHERE ip.invoice_id = i.id\n        AND p.status_id = 3  -- paid status\n    )\n  RETURNING\n    i.id,\n    i.preliminary_delivery_date AS old_date,\n    calculate_preliminary_delivery_date(i.delivery_days, i.delivery_days_type) AS new_date;\nEND;\n$function$\n",
    "comment": null
  },
  "public.update_project_alternative_names_updated_at()": {
    "schema": "public",
    "name": "update_project_alternative_names_updated_at",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.update_project_alternative_names_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n",
    "comment": null
  },
  "public.update_project_templates_updated_at()": {
    "schema": "public",
    "name": "update_project_templates_updated_at",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.update_project_templates_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n",
    "comment": null
  },
  "public.update_updated_at_column()": {
    "schema": "public",
    "name": "update_updated_at_column",
    "arguments": "",
    "purpose": "Custom function",
    "sql": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n",
    "comment": null
  }
}