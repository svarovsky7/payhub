[
  {
    "function": "public.calculate_vat_amounts()",
    "returns": "trigger",
    "summary": "Trigger helper that recalculates vat_amount and amount_without_vat before persisting invoices.",
    "details": "Runs as BEFORE INSERT/UPDATE trigger on public.invoices to derive vat_amount and amount_without_vat based on amount_with_vat and vat_rate.",
    "tables_touched": [
      "public.invoices"
    ],
    "side_effects": [
      "SET NEW.vat_amount",
      "SET NEW.amount_without_vat"
    ],
    "source": "CREATE OR REPLACE FUNCTION public.calculate_vat_amounts()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Если указана сумма с НДС, вычисляем НДС и сумму без НДС\n    IF NEW.amount_with_vat IS NOT NULL THEN\n        IF NEW.vat_rate = 0 THEN\n            NEW.vat_amount = 0;\n            NEW.amount_without_vat = NEW.amount_with_vat;\n        ELSE\n            NEW.vat_amount = ROUND(NEW.amount_with_vat * NEW.vat_rate / (100 + NEW.vat_rate), 2);\n            NEW.amount_without_vat = NEW.amount_with_vat - NEW.vat_amount;\n        END IF;\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$"
  },
  {
    "function": "public.delete_contractor_type(type_id_param integer)",
    "returns": "json",
    "summary": "Safely deletes a contractor type if no contractors depend on it.",
    "details": "Counts rows in public.contractors referencing the type and returns JSON describing the result or blocking deletion.",
    "tables_touched": [
      "public.contractors",
      "public.contractor_types"
    ],
    "side_effects": [
      "DELETE"
    ],
    "source": "CREATE OR REPLACE FUNCTION public.delete_contractor_type(type_id_param integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  contractor_count INTEGER;\n  result JSON;\nBEGIN\n  -- Проверяем есть ли контрагенты с этим типом\n  SELECT COUNT(*) INTO contractor_count\n  FROM public.contractors\n  WHERE type_id = type_id_param;\n\n  IF contractor_count > 0 THEN\n    result := json_build_object(\n      'success', false,\n      'error', 'Невозможно удалить тип, так как существуют контрагенты с этим типом',\n      'contractor_count', contractor_count\n    );\n    RETURN result;\n  END IF;\n\n  -- Удаляем тип контрагента\n  DELETE FROM public.contractor_types WHERE id = type_id_param;\n\n  IF FOUND THEN\n    result := json_build_object(\n      'success', true,\n      'message', 'Тип контрагента успешно удален'\n    );\n  ELSE\n    result := json_build_object(\n      'success', false,\n      'error', 'Тип контрагента не найден'\n    );\n  END IF;\n\n  RETURN result;\nEND;\n$function$"
  },
  {
    "function": "public.delete_project(project_id_param integer)",
    "returns": "boolean",
    "summary": "Removes a project and cleans up user assignments in one call.",
    "details": "Deletes rows from public.user_projects for the project, then deletes the project itself; returns boolean indicating success.",
    "tables_touched": [
      "public.user_projects",
      "public.projects"
    ],
    "side_effects": [
      "DELETE"
    ],
    "source": "CREATE OR REPLACE FUNCTION public.delete_project(project_id_param integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Удаляем все связи с пользователями\n  DELETE FROM public.user_projects WHERE project_id = project_id_param;\n\n  -- Удаляем сам проект\n  DELETE FROM public.projects WHERE id = project_id_param;\n\n  -- Возвращаем true если удаление прошло успешно\n  RETURN FOUND;\nEND;\n$function$"
  },
  {
    "function": "public.handle_new_user()",
    "returns": "trigger",
    "summary": "Provision user_profiles row when a Supabase auth user is created.",
    "details": "Inserts email and full_name (from raw_user_meta_data) into public.user_profiles and returns NEW.",
    "tables_touched": [
      "public.user_profiles"
    ],
    "side_effects": [
      "INSERT"
    ],
    "source": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.user_profiles (id, email, full_name)\n  VALUES (\n    NEW.id,\n    NEW.email,\n    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email)\n  );\n  RETURN NEW;\nEND;\n$function$"
  },
  {
    "function": "public.update_updated_at_column()",
    "returns": "trigger",
    "summary": "BEFORE UPDATE trigger that stamps NEW.updated_at with now().",
    "details": "Mutates the NEW record to keep updated_at current; reused across catalog tables.",
    "tables_touched": [],
    "side_effects": [
      "SET NEW.updated_at"
    ],
    "source": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$"
  }
]
